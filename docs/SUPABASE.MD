### Expansion Plan: Integrating Supabase Backend for Multi-User (Patient and Practitioner) Health Wallet iOS App

This plan outlines how to evolve your existing single-user iOS app (assumed to be patient-focused, with basic FHIR integration for health records) into a multi-user platform supporting both patients and practitioners. We'll use Supabase as the backend for authentication, database storage, realtime features (e.g., chat and notifications), and file storage. Supabase's PostgreSQL database can store FHIR resources as JSONB for compliance with health data standards, while its Row-Level Security (RLS) ensures role-based access.

Key assumptions:
- Your current app is built in Swift/SwiftUI and already handles basic FHIR queries (e.g., via SMART on FHIR).
- We'll integrate Supabase to handle user management, record sharing, and collaboration, potentially syncing FHIR data into Supabase for easier access (using tools like Peliqan for ETL if needed).
- Focus on HIPAA/GDPR compliance: Supabase offers HIPAA-eligible plans (as of 2025); use enterprise tier or self-host for production. Consult legal experts—health data requires explicit consent logging.
- Timeline: 6-10 weeks for MVP, depending on team size.
- Tech Stack: iOS (SwiftUI), Supabase Swift client, FHIRModels for data parsing.

#### 1. Project Setup and Supabase Configuration (1-2 weeks)
- **Create Supabase Project**: Sign up at supabase.com (or self-host for compliance). Enable Auth, Database, Realtime, and Storage modules. Use the dashboard to set up.
- **Install Supabase Swift Client**: In your Xcode project, add via Swift Package Manager (SPM):
  ```
  dependencies: [
      .package(url: "https://github.com/supabase/supabase-swift.git", from: "2.0.0")  // Latest as of 2025
  ]
  ```
  Import in your app: `import Supabase`.
- **Environment Setup**: Store Supabase URL and anon key in a `.env` file or Xcode config. Initialize client:
  ```swift
  let supabase = SupabaseClient(supabaseURL: URL(string: "https://your-project.supabase.co")!, supabaseKey: "your-anon-key")
  ```
- **FHIR Integration Strategy**: Store FHIR resources (e.g., Patient, Observation) as JSONB in Supabase tables. Use Peliqan (from integrations) to sync data from external FHIR servers (e.g., Epic) into Supabase. Alternatively, proxy FHIR API calls through Supabase Edge Functions for security.

#### 2. Database Schema Design
Use Supabase's PostgreSQL with JSONB for flexible FHIR storage. Key tables (create via dashboard or SQL):

- **users** (auto-generated by Supabase Auth, extend with metadata):
  - id (UUID, PK)
  - email, phone, etc.
  - role (enum: 'patient', 'practitioner') – Add via post-signup trigger.

- **patients** (linked to users):
  - user_id (FK to users)
  - fhir_patient_json (JSONB: Full FHIR Patient resource)
  - assigned_practitioners (array of UUIDs)

- **practitioners** (linked to users):
  - user_id (FK to users)
  - license_info (text)
  - managed_patients (array of UUIDs) – For multi-patient dashboard

- **health_records** (core FHIR storage):
  - id (UUID, PK)
  - patient_id (FK to patients)
  - record_type (enum: 'observation', 'medication', etc.)
  - fhir_data (JSONB: FHIR resource payload)
  - shared_with (array of UUIDs: Practitioners with access)
  - version_history (JSONB array: For audits)

- **chats** (for patient-practitioner messaging):
  - id (UUID, PK)
  - participants (array of UUIDs)
  - messages (JSONB array: [{sender_id, text, timestamp, attachments}])

- **notifications** (for alerts, e.g., hospital admissions):
  - id (UUID, PK)
  - recipient_id (UUID)
  - type (enum: 'alert', 'update')
  - payload (JSONB)
  - status (enum: 'sent', 'read')

Enable RLS on all tables to enforce access:
- Patients: Can only read/write their own records (policy: `auth.uid() = patient_id`).
- Practitioners: Can read/write assigned patients' records (policy: `auth.uid() = ANY(shared_with) OR auth.uid() = ANY(managed_patients)`).
- Use Supabase dashboard to define policies, e.g.:
  ```sql
  CREATE POLICY "Patient own records" ON health_records FOR ALL USING (auth.uid() = patient_id);
  ```

#### 3. Authentication and Role Management
- **Signup/Login**: Use Supabase Auth for email/password, Apple Sign-In (integrate via ASAuthorizationAppleIDProvider), or OAuth.
  - On signup, assign role: Use a PostgREST trigger or Edge Function to insert into users metadata.
  - Example iOS code for signup with role:
    ```swift
    try await supabase.auth.signUp(email: email, password: password, data: ["role": "patient"])  // Metadata for role
    ```
- **Role-Based UI**: On login, fetch user role:
  ```swift
  let session = try await supabase.auth.session
  let role = session.user.userMetadata["role"] as? String
  // Route to PatientView or PractitionerDashboard based on role
  ```
- **Consent and Sharing**: Log consents in a `consents` table (immutable via triggers). For sharing, update `shared_with` array with patient approval.

#### 4. Core Feature Implementation (3-5 weeks)
Expand the app with role-specific views using SwiftUI.

- **Patient Version**:
  - Dashboard: Fetch and display personal records from Supabase.
    ```swift
    let records = try await supabase.database.from("health_records").select().eq("patient_id", value: session.user.id).execute().value as [HealthRecord]
    // Parse FHIR JSONB with FHIRModels: let patient = try FHIRModels.Patient(json: records[0].fhir_data)
    ```
  - Sharing: Button to add practitioner UUID to `shared_with`.
  - Chat/Notifications: Realtime subscription for messages.
    ```swift
    supabase.realtime.channel("chats:\(chatId)").on(.all) { message in
        // Update UI with new message
    }.subscribe()
    ```
    Send notifications via insert to `notifications` table; use APNs integration if needed for pushes.

- **Practitioner Version**:
  - Multi-Patient Dashboard: Query managed patients.
    ```swift
    let patients = try await supabase.database.from("patients").select().in("user_id", values: managedPatientIds).execute().value
    ```
  - Record Viewing/Sharing: Fetch shared records, annotate, and update via Supabase upsert.
  - Collaboration: Group chats via multi-participant channels.

- **Realtime Features**:
  - Chat: Use Supabase Realtime broadcasts for low-latency messaging.
  - Notifications: Subscribe to user-specific channels (e.g., "notifications:user_id").
  - Hospital Alerts: Patient app detects location (via CoreLocation), inserts alert to notifications; practitioner subscribes for pushes.

- **FHIR Sync**:
  - Pull from external FHIR server into Supabase on app load (use URLSession for API calls, then insert to DB).
  - For writes, update Supabase first, then push to FHIR server via Edge Function (serverless JS in Supabase).

#### 5. Security and Compliance
- **Encryption**: Use Supabase's built-in pg_crypto for sensitive fields; E2EE for chats (implement client-side with CryptoKit).
- **Auditing**: Enable Supabase logs; add triggers for change history.
- **HIPAA Notes**: Use Supabase's HIPAA plan (BAA available). Avoid storing PHI in realtime payloads—use IDs only.
- **Error Handling**: Implement retries for network operations and monitor auth state with the async sequence API:
  ```swift
  Task {
    for await (event, session) in supabase.auth.stateChanges {
      switch event {
      case .initialSession, .accessTokenRefreshed:
        guard let session = session else { return }
        // Update cached credentials via SupabaseService.shared
        await AppLockManager.shared.handle(session: session)
      case .signedOut:
        await AppLockManager.shared.handleSignOut()
      default:
        break
      }
    }
  }
  ```

#### 6. Testing and Deployment (1-2 weeks)

- **Unit/UI Tests**: Use XCTest for auth flows, data fetching. Mock Supabase with a local instance.
- **Beta Testing**: Use TestFlight; validate with synthetic FHIR payloads before capturing real PHI.
- **Deployment**: Build for App Store; configure Supabase webhooks for production alerts.
- **Monitoring**: Use Supabase analytics; integrate Sentry (or similar) for runtime errors.


#### Potential Challenges and Mitigations

- **Performance**: Large FHIR JSONB—paginate queries (Supabase supports limits/offsets).
- **Cross-Platform**: If expanding beyond iOS, use Supabase's JS client for web.
- **Cost**: Free tier for dev; scale to paid for realtime usage.
- **Learning Curve**: Follow Supabase iOS quickstarts and YouTube tutorials for hands-on.


This plan keeps the app modular—start with auth and DB integration, then add features iteratively. If you need code templates, wireframes, or adjustments (e.g., self-hosted Supabase), let me know!
